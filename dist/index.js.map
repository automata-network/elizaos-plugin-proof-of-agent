{"version":3,"sources":["../src/actions/claimTokenAction.ts","../src/providers/proofProvider.ts","../src/index.ts"],"sourcesContent":["import { type IAgentRuntime, type Memory, type State, type HandlerCallback, elizaLogger, composeContext, generateObjectDeprecated, ModelClass, Action, parseJSONObjectFromText } from \"@elizaos/core\";\nimport { ProofProvider } from \"../providers/proofProvider\"\nimport { TEEMode } from \"@elizaos/plugin-tee\";\n\nconst claimTemplate = `\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\n\nExample response:\n\\`\\`\\`json\n{\n    \"recipient\": \"0x3b1f8782d6023137b8ff26f82de164abdb6760ef\",\n    \"assets\": [\"holesky_eth\"]\n}\n\\`\\`\\`\n\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nHere's a list of supported assets:\n<supported_assets>\n{{supportedAssets}}\n</supported_assets>\n\nHere's a list of explorer links for every assets:\n<assets_explorer>\n{{assetsExplorer}}\n</assets_explorer>\n\nYour goal is to extract the following information about the claim:\n1. Asset name to claim (must be one of the supported assets)\n2. Recipient address (must be a valid Ethereum address)\n\ngenerate the message follow these steps, put it into the <analysis> tag:\n1. Identify the relevant information from the user's message, not from the agent, only use the message within 5 mins:\n   - Quote the message mentioning the assets.\n     - only use the message within 5 min\n   - Quote the part mentioning the recipient address.\n     - Prefer to use the most recently address\n     - only use the message within 5 min\n\n2. Validate each piece of information:\n   - Assets: List all supported assets and check if the mentioned asset is in the list, the length must be greater than 0. if the asset name can be fuzzy match.\n   - Address: Check that it starts with \"0x\" and count the number of characters (should be 42).\n\n3. If any information is missing or invalid, prepare an appropriate error message.\n\n4. If all information is valid, summarize your findings.\n\n5. Prepare the JSON structure based on your analysis.\n\n6. If there some reason that you can't extract the data, please guide the user how to provide it, it should matches the character's style and voice, and put it to the <hint> tag.\n\n7. If the validation passed, you should prepare an appropriate message to guide the user what to do after the claim successed, and put it to the <claimed> tags:\n   - Tell the user that which assets are request to claim, claim to which recipient\n   - Tell the user that the claim is on the way, check it from the explorer links, multiple assets should have multiple links.\n   - The explorer links is different from every assets. you can compose it by \\`$explorerURL/address/$recipient\\` the format.\n   - The order of assets_explorer is same as the supported_assets\n   - Multiple explorer links should separate with different lines\n\nAll fields are required. The JSON should have this structure:\n\n\n\n\\`\\`\\`json\n{\n    \"recipient\": string,\n    \"assets\": string[],\n    \"analysis\": string,\n    \"hint\": string,\n    \"claimed\": string\n}\n\\`\\`\\`\n\nRemember:\n- The assets name must be a string and must exactly match one of the supported assets, and the list should only exactly from one message, do not aggregate from multiple messages.\n- The recipient address must be a valid Ethereum address starting with \"0x\".\n- The data extract must from the user message.\n- The JSON output should be properly formatted using Markdown blocks.\n\nNow, process the user's request and provide your response.\n`;\n\nexport const claimTokenAction: Action = {\n    name: \"CLAIM_TOKEN\",\n    similes: [\"PROOF_OF_AGENT\", \"proofof_agent\"],\n    description: \"claim token from proof of agent\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        _options?: { [key: string]: unknown },\n        callback?: HandlerCallback,\n    ) => {\n        try {\n            // Get the remote attestation of the agentId\n            const agentId = runtime.agentId;\n            const teeMode = runtime.getSetting(\"TEE_MODE\");\n            const sgxMode = runtime.getSetting(\"SGX\");\n            const poaRelay = (runtime.getSetting(\"PROOF_OF_AGENT_RELAY\") as string) || \"https://proof-of-agent-relay.ata.network\";\n\n            const provider = new ProofProvider(poaRelay, sgxMode, teeMode);\n            if (!provider.isValid()) {\n                if (callback) {\n                    callback({ text: \"Failed: You can only claim tokens after enabling TEE\" });\n                }\n                return false;\n            }\n\n            // Initialize or update state\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n\n            const assetsInfo = await provider.queryAssets();\n\n            const queryContext = composeContext({\n                state: {\n                    ...state,\n                    supportedAssets: assetsInfo.assets,\n                    assetsExplorer: assetsInfo.explorers,\n                },\n                template: claimTemplate,\n            });\n\n            // Generate transfer content\n            const content = await generateObjectDeprecated({\n                runtime,\n                context: queryContext,\n                modelClass: ModelClass.LARGE,\n            });\n\n            elizaLogger.info(\"content: \" + JSON.stringify(content));\n\n            if (!content.assets || content.assets.length == 0 || !content.recipient) {\n                if (callback) {\n                    callback({ text: content.hint, action: \"CONTINUE\" });\n                }\n                return false;\n            }\n\n            const requestData = await provider.requestClaim(content);\n            if (requestData.error) {\n                if (callback) {\n                    callback({ text: \"Failed: \" + requestData.error });\n                }\n                return false;\n            }\n\n            const quote = await provider.generateAttestation(requestData.hash);\n            if (!quote) {\n                if (callback) {\n                    callback({ text: \"Generate Proof Failed: please specify the TEE Mode\" });\n                }\n                return false;\n            }\n\n            const result = await provider.submitClaim({\n                attestation_report: quote,\n                context: requestData.context,\n            });\n            if (result.error) {  // Changed from requestData.error to result.error\n                if (callback) {\n                    callback({ text: \"Failed: \" + result.error });  // Changed to result.error\n                }\n                return false;\n            }\n\n            const output = JSON.stringify(requestData);\n            const text = result.success ? content.claimed : \"Claim Failed\";\n            if (callback) {\n                callback({ text: text });\n            }\n            return true;\n        } catch (error) {\n            console.error(\"Failed to fetch claim token: \", error);\n            return false;\n        }\n    },\n    validate: async (runtime: IAgentRuntime) => {\n        const teeMode = runtime.getSetting(\"TEE_MODE\");\n        const sgxMode = runtime.getSetting(\"SGX\");\n        return (teeMode && teeMode != TEEMode.OFF) || !!sgxMode;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"I want to claim the {{asset}} token to {{ethereum address}}\",\n                    action: \"CLAIM_TOKEN\",\n                },\n            }\n        ],\n    ],\n    suppressInitialMessage: true,\n};","import {\n    IAgentRuntime,\n    Memory,\n    Provider,\n    State,\n    elizaLogger,\n} from \"@elizaos/core\";\n\nimport { RemoteAttestationProvider, TEEMode } from \"@elizaos/plugin-tee\";\nimport { SgxAttestationProvider } from \"@elizaos/plugin-sgx\";\nimport { send_rpc_request } from \"@phala/dstack-sdk\";\nimport { createHash } from 'crypto';\n\nexport function to_hex(data: string | Buffer | Uint8Array): string {\n    if (typeof data === 'string') {\n        return Buffer.from(data).toString('hex');\n    }\n    if (data instanceof Uint8Array) {\n        return Buffer.from(data).toString('hex');\n    }\n    return (data as Buffer).toString('hex');\n}\n\nexport interface RequestClaimReq {\n    recipient: string,\n    assets: string[],\n}\n\nexport interface SubmitClaimReq {\n    attestation_report: string,\n    context: string,\n}\n\nclass ProofProvider {\n    private tdx: RemoteAttestationProvider | null = null;\n    private sgx: SgxAttestationProvider | null = null;\n    private relayUrl: string;\n    private valid: boolean = false;\n\n    constructor(relayUrl: string, sgxMode: string | null, teeMode: string | null) {\n        if (teeMode && teeMode != TEEMode.OFF) {\n            this.tdx = new RemoteAttestationProvider(teeMode);\n            this.valid = true;\n        } else if (sgxMode) {\n            this.sgx = new SgxAttestationProvider();\n            this.valid = true;\n        }\n        this.relayUrl = relayUrl;\n    }\n\n    async isValid() {\n        return this.valid;\n    }\n\n    async generateAttestation(reportData: string) {\n        elizaLogger.log(\"poa-generateAttestation:\", reportData);\n        if (this.tdx) {\n            const report = await this.tdx.generateAttestation(reportData, 'sha256');\n            return report.quote;\n        } else if (this.sgx) {\n            const report = await this.sgx.generateAttestation(reportData);\n            return report.quote;\n        } else {\n            return null;\n        }\n    }\n\n    async queryAssets() {\n        const response = await send_rpc_request(this.relayUrl, \"/poa/queryAssets\", `{}`);\n        return response;\n    }\n\n    async requestClaim(req: RequestClaimReq) {\n        const response = await send_rpc_request(this.relayUrl, \"/poa/requestClaim\", JSON.stringify(req));\n        return response;\n    }\n\n    async submitClaim(req: SubmitClaimReq) {\n        const response = await send_rpc_request(this.relayUrl, \"/poa/submitClaim\", JSON.stringify(req));\n        return response;\n    }\n}\n\nfunction hexToUint8Array(hex: string) {\n    hex = hex.trim();\n    if (!hex) {\n      throw new Error(\"Invalid hex string\");\n    }\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.substring(2);\n    }\n    if (hex.length % 2 !== 0) {\n      throw new Error(\"Invalid hex string\");\n    }\n\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n      const byte = parseInt(hex.slice(i, i + 2), 16);\n      if (isNaN(byte)) {\n        throw new Error(\"Invalid hex string\");\n      }\n      array[i / 2] = byte;\n    }\n    return array;\n}\n\nexport { ProofProvider };","import { Plugin } from \"@elizaos/core\";\nimport { claimTokenAction } from \"./actions/claimTokenAction\";\n\nexport { ProofProvider } from \"./providers/proofProvider\";\n\n\nexport const proofOfAgentPlugin: Plugin = {\n    name: \"proofOfAgent\",\n    description:\n        \"proof of agent\",\n    actions: [\n        claimTokenAction,\n    ],\n    evaluators: [\n        /* custom evaluators */\n    ],\n    providers: [\n        /* custom providers */\n        // deriveKeyProvider,\n    ],\n    services: [\n        /* custom services */\n    ],\n};\n"],"mappings":";AAAA,SAA4E,eAAAA,cAAa,gBAAgB,0BAA0B,kBAAmD;;;ACAtL;AAAA,EAKI;AAAA,OACG;AAEP,SAAS,2BAA2B,eAAe;AACnD,SAAS,8BAA8B;AACvC,SAAS,wBAAwB;AAuBjC,IAAM,gBAAN,MAAoB;AAAA,EAMhB,YAAY,UAAkB,SAAwB,SAAwB;AAL9E,SAAQ,MAAwC;AAChD,SAAQ,MAAqC;AAE7C,SAAQ,QAAiB;AAGrB,QAAI,WAAW,WAAW,QAAQ,KAAK;AACnC,WAAK,MAAM,IAAI,0BAA0B,OAAO;AAChD,WAAK,QAAQ;AAAA,IACjB,WAAW,SAAS;AAChB,WAAK,MAAM,IAAI,uBAAuB;AACtC,WAAK,QAAQ;AAAA,IACjB;AACA,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,MAAM,UAAU;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,MAAM,oBAAoB,YAAoB;AAC1C,gBAAY,IAAI,4BAA4B,UAAU;AACtD,QAAI,KAAK,KAAK;AACV,YAAM,SAAS,MAAM,KAAK,IAAI,oBAAoB,YAAY,QAAQ;AACtE,aAAO,OAAO;AAAA,IAClB,WAAW,KAAK,KAAK;AACjB,YAAM,SAAS,MAAM,KAAK,IAAI,oBAAoB,UAAU;AAC5D,aAAO,OAAO;AAAA,IAClB,OAAO;AACH,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAM,cAAc;AAChB,UAAM,WAAW,MAAM,iBAAiB,KAAK,UAAU,oBAAoB,IAAI;AAC/E,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,aAAa,KAAsB;AACrC,UAAM,WAAW,MAAM,iBAAiB,KAAK,UAAU,qBAAqB,KAAK,UAAU,GAAG,CAAC;AAC/F,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,YAAY,KAAqB;AACnC,UAAM,WAAW,MAAM,iBAAiB,KAAK,UAAU,oBAAoB,KAAK,UAAU,GAAG,CAAC;AAC9F,WAAO;AAAA,EACX;AACJ;;;AD/EA,SAAS,WAAAC,gBAAe;AAExB,IAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+Ef,IAAM,mBAA2B;AAAA,EACpC,MAAM;AAAA,EACN,SAAS,CAAC,kBAAkB,eAAe;AAAA,EAC3C,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACC;AACD,QAAI;AAEA,YAAM,UAAU,QAAQ;AACxB,YAAM,UAAU,QAAQ,WAAW,UAAU;AAC7C,YAAM,UAAU,QAAQ,WAAW,KAAK;AACxC,YAAM,WAAY,QAAQ,WAAW,sBAAsB,KAAgB;AAE3E,YAAM,WAAW,IAAI,cAAc,UAAU,SAAS,OAAO;AAC7D,UAAI,CAAC,SAAS,QAAQ,GAAG;AACrB,YAAI,UAAU;AACV,mBAAS,EAAE,MAAM,uDAAuD,CAAC;AAAA,QAC7E;AACA,eAAO;AAAA,MACX;AAGA,UAAI,CAAC,OAAO;AACR,gBAAS,MAAM,QAAQ,aAAa,OAAO;AAAA,MAC/C,OAAO;AACH,gBAAQ,MAAM,QAAQ,yBAAyB,KAAK;AAAA,MACxD;AAEA,YAAM,aAAa,MAAM,SAAS,YAAY;AAE9C,YAAM,eAAe,eAAe;AAAA,QAChC,OAAO;AAAA,UACH,GAAG;AAAA,UACH,iBAAiB,WAAW;AAAA,UAC5B,gBAAgB,WAAW;AAAA,QAC/B;AAAA,QACA,UAAU;AAAA,MACd,CAAC;AAGD,YAAM,UAAU,MAAM,yBAAyB;AAAA,QAC3C;AAAA,QACA,SAAS;AAAA,QACT,YAAY,WAAW;AAAA,MAC3B,CAAC;AAED,MAAAC,aAAY,KAAK,cAAc,KAAK,UAAU,OAAO,CAAC;AAEtD,UAAI,CAAC,QAAQ,UAAU,QAAQ,OAAO,UAAU,KAAK,CAAC,QAAQ,WAAW;AACrE,YAAI,UAAU;AACV,mBAAS,EAAE,MAAM,QAAQ,MAAM,QAAQ,WAAW,CAAC;AAAA,QACvD;AACA,eAAO;AAAA,MACX;AAEA,YAAM,cAAc,MAAM,SAAS,aAAa,OAAO;AACvD,UAAI,YAAY,OAAO;AACnB,YAAI,UAAU;AACV,mBAAS,EAAE,MAAM,aAAa,YAAY,MAAM,CAAC;AAAA,QACrD;AACA,eAAO;AAAA,MACX;AAEA,YAAM,QAAQ,MAAM,SAAS,oBAAoB,YAAY,IAAI;AACjE,UAAI,CAAC,OAAO;AACR,YAAI,UAAU;AACV,mBAAS,EAAE,MAAM,qDAAqD,CAAC;AAAA,QAC3E;AACA,eAAO;AAAA,MACX;AAEA,YAAM,SAAS,MAAM,SAAS,YAAY;AAAA,QACtC,oBAAoB;AAAA,QACpB,SAAS,YAAY;AAAA,MACzB,CAAC;AACD,UAAI,OAAO,OAAO;AACd,YAAI,UAAU;AACV,mBAAS,EAAE,MAAM,aAAa,OAAO,MAAM,CAAC;AAAA,QAChD;AACA,eAAO;AAAA,MACX;AAEA,YAAM,SAAS,KAAK,UAAU,WAAW;AACzC,YAAM,OAAO,OAAO,UAAU,QAAQ,UAAU;AAChD,UAAI,UAAU;AACV,iBAAS,EAAE,KAAW,CAAC;AAAA,MAC3B;AACA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,cAAQ,MAAM,iCAAiC,KAAK;AACpD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,UAAU,OAAO,YAA2B;AACxC,UAAM,UAAU,QAAQ,WAAW,UAAU;AAC7C,UAAM,UAAU,QAAQ,WAAW,KAAK;AACxC,WAAQ,WAAW,WAAWD,SAAQ,OAAQ,CAAC,CAAC;AAAA,EACpD;AAAA,EACA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,wBAAwB;AAC5B;;;AEhMO,IAAM,qBAA6B;AAAA,EACtC,MAAM;AAAA,EACN,aACI;AAAA,EACJ,SAAS;AAAA,IACL;AAAA,EACJ;AAAA,EACA,YAAY;AAAA;AAAA,EAEZ;AAAA,EACA,WAAW;AAAA;AAAA;AAAA,EAGX;AAAA,EACA,UAAU;AAAA;AAAA,EAEV;AACJ;","names":["elizaLogger","TEEMode","elizaLogger"]}